# Импортируем нужные библиотеки и определяем константу количества итераций
import random
from math import ceil
number_of_iteration = 20

#---------------------------------------------------
# Класс, описывающий муравья, используемого в нашем алгоритме
class Ant:
    def __init__(self, color_of_ant):
        self.color = color_of_ant           # Цвет муравья
#---------------------------------------------------

#---------------------------------------------------
# Класс описывающий вершину графа
class Node:
    def __init__(self):
        self.ants = []                      # Список муравьев, находящихся в вершине
        self.adjacent = []                  # Список смежных вершин
        self.color = None                   # Цвет вершины
        self.adjacent_len = 0               # Размер списка смежных вершин
#---------------------------------------------------

#---------------------------------------------------
# Функция, находящая верхнюю границу и создающая вершины
def initialization(data, tops, number):
    edge = 0                                        # Инициализируем количество ребер

    for i in range(number):
        tops.append(Node())                         # Добавляем вершины в граф
        for j in range(number):                     # Добавляем смежные вершины
            if (data[i][j] == '1'):
                tops[i].adjacent.append(j + 1)
                tops[i].adjacent_len += 1

        edge += tops[i].adjacent_len                # Считаем количество ребер (их будет в 2 раза больше, чем надо)

    # Истинное значение edge = 1/2 * текущий_edge, в в формуле edge умножается на 2 --> получается 1
    # Вычисляем верхнюю границу
    bound = 1 / 2 + (edge + 1 / 4) ** 0.5
    bound = ceil(bound)

    return bound
#---------------------------------------------------

#---------------------------------------------------
# Функция, инициализирующая феромон
def initialization_feromone(number, bound):
    # Создаем одномерный список
    pheromon = [0] * number
    for i in range(number):
        pheromon[i] = [1] * bound                   # Создаем двумерный список, содержащий единичные значения

    return pheromon
#---------------------------------------------------

#---------------------------------------------------
# Функция, создающая муравьев на каждой вершине графа
def creating_ants(top, number, bound):
    # Инициализируем все поля
    top.ants = []
    top.color = None
    # Для вершины создаем number муравьев
    for j in range(number):
        top.ants.append(Ant(random.randint(1, bound)))

    return top
#---------------------------------------------------

#---------------------------------------------------
# Функция, определяющая цвет вершины
def color_definition(pheromon, node, id, number, bound):
    # Проверка на то, что в данной вершине нет муравьев
    if (len(node[id].ants) == 0):
        while True:
            # Создаем новую колонию муравьев
            node[id] = creating_ants(node[id], number, bound)

            # Удаляем муравьев цвета смежных вершин (чтобы не получить неправильную раскраску)
            for i in range(node[id].adjacent_len):
                if (node[node[id].adjacent[i] - 1].color != None):
                    counter = 0
                    size = len(node[id].ants)
                    while (counter < size):
                        if (node[node[id].adjacent[i] - 1].color == node[id].ants[counter].color):
                            del node[id].ants[counter]
                            size -= 1
                        else:
                            counter += 1
            
            # Если колония на нашем узле не опустела, выходим из цикла, иначе -- повторяем цикл
            if (len(node[id].ants) != 0):
                break

    # Создаем перечень муравьев в данной вершине и вычисляем знаменатель нашей дроби
    # Идекс -- цвет, значение -- количество муравьев с этим цветом
    numbers_of_ants = [0] * bound
    denominator = 0
    # Высчитываем количество муравьев одного цвета
    for i in range(len(node[id].ants)):
        numbers_of_ants[node[id].ants[i].color - 1] += 1
        # pheromon[id][node[id].ants[i].color - 1] -- обратная связь с предыдущего прохода относительно цвета, указанного во втором индексе
        denominator += pheromon[id][node[id].ants[i].color - 1]         # Умножается на еще одного добавленного муравья (* 1). Мы это здесь не пишем

    # Выбираем рандомное значение из возможного промежутка (от 0 до 1). На его основе будем выбирать цвет
    roulette = random.random()
    sum = 0

    # Создаем список вероятностей окрашивания вершины в i-ый цвет и выбираем цвет
    interval = [0] * bound
    for i in range(bound):
        interval[i] = pheromon[id][i] * numbers_of_ants[i] / denominator
        sum += interval[i]
        if (roulette < sum):
            color = i + 1
            break
        
    # Мы выбрали i-ый цвет. Теперь нужно "вытянуть" муравьев этого цвета из других НЕРАСКРАШЕННЫХ вершин
    # Также нам нужно передать муравьев цвета отличного от цвета вершины в другие вершины
    alien_ants = []                                                         # Список муравьев других вершин
    for i in range(node[id].adjacent_len):
        if (node[node[id].adjacent[i] - 1].color == None):
            # Формируем список цветов муравьев, которых мы передаем
            # Первое значение каждого одномерного списка -- имя вершины, у которой мы смотрим муравьев
            helper = []
            helper.append(node[id].adjacent[i])
            helper.extend([0] * bound)

            size = len(node[node[id].adjacent[i] - 1].ants)
            j = 0
            while (j < size):
                # Выбираем смежную вершину и смотрим ее муравьев. Если они нужного нам цвета, вытягиваем их
                # Можно просто удалить, так как мы уже нашли цвет нашей вершины
                if (node[node[id].adjacent[i] - 1].ants[j].color == color):
                    del node[node[id].adjacent[i] - 1].ants[j]
                    size -= 1
                else:
                # Если цвет не совпал, учитываем муравья в нашем посчете
                    helper[node[node[id].adjacent[i] - 1].ants[j].color] += 1
                    j += 1
            
            alien_ants.append(helper)

    # Высчитываем вероятность попадание муравья в вершину alien_ants[j][0]
    i = 0
    size = len(node[id].ants)
    while (i < size):
        # Если муравей цвета вершины, пропускаем его
        if (node[id].ants[i].color == color):
            i += 1
            continue

        # Вычисляем знаменатель дроби для текущего цвета
        denominator = 0
        for j in range(len(alien_ants)):
            denominator += alien_ants[j][node[id].ants[i].color]

        if (denominator != 0):                                              # Если муравьи искомого цвета существуют
            
            # Выбираем рандомное значение из возможного промежутка (от 0 до 1). На его основе будем выбирать вершину
            roulette = random.random()
            sum = 0

            # Подсчитываем вероятность попадания муравья в вершину
            interval = [0] * len(alien_ants)
            for j in range(len(alien_ants)):
                interval[j] = alien_ants[j][node[id].ants[i].color] / denominator
                sum += interval[j]
                if (roulette < sum):
                    point = alien_ants[j][0] - 1
                    break                

            # Отправляем муравья в выбранную вершину
            node[point].ants.append(node[id].ants[i])
            del node[id].ants[i]

        else:                                                               # Иначе помещаем муравья в случайную вершину
            random_id = random.randint(0, node[id].adjacent_len - 1)
            node[node[id].adjacent[random_id] - 1].ants.append(node[id].ants[i])
            del node[id].ants[i]

        size -= 1

    return color
#---------------------------------------------------

#---------------------------------------------------
# Функция, обновляющая феромон
def update_pheromon(pheromon, current_coloring, col_num, number, bound):
    p = 0.9                                                                 # Параметр испарения
    for i in range(number):
        for j in range(bound):
            pheromon[i][j] *= p
    
    for i in range(number):
        pheromon[i][current_coloring[i + 1] - 1] += 1 / col_num

    return pheromon
#---------------------------------------------------

#---------------------------------------------------
# Функция, красящая наш граф с помощью алгоритма муравьиной колонии
def coloring(data, number):
    best_coloring = {}                                                      # Лучшая раскраска
    best_col_num = 0                                                        # Количество цветов в лучшей раскраске
    counter = 1                                                             # Инициализация счетчика итераций
    tops = []                                                               # Создаем пустой список, в котором будем хранить вершины графа
    bound = initialization(data, tops, number)                              # Вычисляем верхнюю границу хроматического числа и создаем вершины графа
    pheromon = initialization_feromone(number, bound)                       # Инициализация феромона

    # Пока количество итераций без изменений меньше, либо равно максимальному количеству итераций
    while (counter <= number_of_iteration):
        for i in range(number):
            tops[i] = creating_ants(tops[i], number, bound)              # Создаем начальные колонии на вершинах

        accessible_tops = [i for i in range(number)]                        # Список доступных вершин
        current_coloring = {}                                               # Текущая раскраска
        col_num = 0                                                         # Количество цветов в текущей раскраске

        # Начинаем покраску графа
        for i in range(number):
            # Выбираем рандомную вершину графа и красим ее
            random_id = random.randint(0, len(accessible_tops) - 1)
            tops[accessible_tops[random_id]].color = color_definition(pheromon, tops, accessible_tops[random_id], number, bound)
            # Добавляем цвет вершины в словарь, в котором ключ -- имя вершины, значение -- ее цвет
            current_coloring[accessible_tops[random_id] + 1] = tops[accessible_tops[random_id]].color

            # Удаляем вершину из дальнейшего рассмотрения
            del accessible_tops[random_id]

        # Считаем количество задействованных цветов
        helper = current_coloring.values()                                  # Вспомогательный список задействованных в текущей раскраске цветов
        col_num = len(set(helper))                                          # Количество цветов в текущей раскраске
            
        # Обновляем феромон
        pheromon = update_pheromon(pheromon, current_coloring, col_num, number, bound)

        # Обновление счетчика
        if ((col_num < best_col_num) or (len(best_coloring) == 0)):         # Флаг, показывающий была ли найдена более хорошая раскраска или нет
            counter = 1
            best_col_num = col_num
            best_coloring = current_coloring
        else:
            counter += 1
    
    return best_coloring
#---------------------------------------------------
